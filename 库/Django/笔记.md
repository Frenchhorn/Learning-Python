# Writing your first Django app
> [django tutorial documentation](https://docs.djangoproject.com/en/1.11/intro/)

> [django-admin documentation](https://docs.djangoproject.com/en/1.11/ref/django-admin/)

> [Datebase API reference](https://docs.djangoproject.com/en/1.11/topics/db/queries/)

## Creating a project
`django-admin startproject mysite`

These folders and files will be created:
```
mysite/
    manage.py
    mysite/
        __init__.py
        settings.py
        urls.py
        wsgi.py
```

## The development server
`python manage.py runserver`

You'll see the following output on the command line:
```
Performing system checks...

System check identified no issues (0 silenced).

You have unapplied migrations; your app may not work properly until they are applied.
Run 'python manage.py migrate' to apply them.

August 07, 2017 - 15:50:53
Django version 1.11, using settings 'mysite.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
```

### Set the port
`python manage.py runserver 8080`

## Creating the Polls app
`python manage.py startapp polls`

These folders and files will be created:
```
polls/
    __init__.py
    admin.py
    apps.py
    migrations/
        __init__.py
    models.py
    tests.py
    views.py
```

## Write your first view

Open th file `polls/views.py` and put the following code in it:
```python
from django.http import HttpResponse

def index(request):
    return HttpResponse("Hello, world. You're at the polls index")
```

Create a file `polls/urls.py` for mapping the function `index` to a URL
```python
from django.conf.urls import url
from . import views

urlpatterns = [
    url(r'^$', views.index, name='index'),
]
```

Point the root URLconf at the `polls.urls` module. Add following code to `mysite/urls.py`:
```python
from django.conf.urls import include, url
from django.contrib import admin

urlpatterns = [
    url(r'polls/', include('polls.urls')),
    url(r'^admin/', admin.site.urls),
]
```

The **url()** function is passed four arguments, two required: **regex** and **view**, and two optional: **kwargs**, and **name**.

## Database setup

Default setting in `mysite/settings.py` `DATABASES`
* **ENGINE** - Either `django.db.backends.sqlite3`, `django.db.backends.postgresql`, `django.db.backends.mysql`, or `django.db.backends.oracle`. Other backends are also available.
* **NAME** -  The name of your database. If youâ€™re using SQLite, it should be the full absolute path of that file.

If you are not using SQLite, additional settings such as **USER**, **PASSWORD**, and **HOST** must be added. [Reference documentation](https://docs.djangoproject.com/en/1.11/ref/settings/#std:setting-DATABASES)

Create database:
`python manage.py migrate`

## Creating models

We will create two models: **Question** and **Choice**.
A **Question** has a question and a publication date.
A **Choice** has two field: the text of the choice and a vote tally.
Each **Choice** is associated with a **Question**.

Edit the `polls/models.py` file:
```python
from django.db import models

class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')

class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
```

## Activating models

First, you should add the app **polls** to your project.

In `mysite/settings.py`:
```
INSTALLED_APPS = [
    'polls.apps.PollsConfig',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
```
Then, make migrations:

`python manage.py makemigrations polls`

You should see following:
```
Migrations for 'polls':
  polls/migrations/0001_initial.py:
    - Create model Choice
    - Create model Question
    - Add field question to choice
```

The **sqlmigrate** command takes migration names and returns their SQL (just print):

`python manage.py sqlmigrate polls 0001`

Last, run **migrate**:

`python manage.py migrate`

### Three-step guide to making model changes
* Change your models(in `models.py`)
* Run `python manage.py makemigrations` to create migrations for those changes
* Run `python manage.py migrate` to apply those changes to the database

## Playing with the ORM API

Using this instead of simply typing **python**, because manage.py sets the **DJANGO_SETTINGS_MODULE** environment variable.

`python manage.py shell`

```python
>>> from polls.models import Question, Choice   # Import the model classes we just wrote.

# No questions are in the system yet.
>>> Question.objects.all()
<QuerySet []>

# Create a new Question.
# Support for time zones is enabled in the default settings file, so
# Django expects a datetime with tzinfo for pub_date. Use timezone.now()
# instead of datetime.datetime.now() and it will do the right thing.
>>> from django.utils import timezone
>>> q = Question(question_text="What's new?", pub_date=timezone.now())

# Save the object into the database. You have to call save() explicitly.
>>> q.save()

# Now it has an ID. Note that this might say "1L" instead of "1", depending
# on which database you're using. That's no biggie; it just means your
# database backend prefers to return integers as Python long integer
# objects.
>>> q.id
1

# Access model field values via Python attributes.
>>> q.question_text
"What's new?"
>>> q.pub_date
datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=<UTC>)

# Change values by changing the attributes, then calling save().
>>> q.question_text = "What's up?"
>>> q.save()

# objects.all() displays all the questions in the database.
>>> Question.objects.all()
<QuerySet [<Question: Question object>]>
```

**<Question: Question object>** is, utterly, an unhelpful representation of this object.
Let's fix that by editing the **Question** model in the `polls/models.py`
```python
class Question(models.Model):
    # ...
    def __str__(self):
        return self.question_text

class Choice(models.Model):
    # ...
    def __str__(self):
        return self.choic_text
```

Try other APIs:
```python
>>> from polls.models import Question, Choice

# Make sure our __str__() addition worked.
>>> Question.objects.all()
<QuerySet [<Question: What's up?>]>

# Django provides a rich database lookup API that's entirely driven by
# keyword arguments.
>>> Question.objects.filter(id=1)
<QuerySet [<Question: What's up?>]>
>>> Question.objects.filter(question_text__startswith='What')
<QuerySet [<Question: What's up?>]>

# Get the question that was published this year.
>>> from django.utils import timezone
>>> current_year = timezone.now().year
>>> Question.objects.get(pub_date__year=current_year)
<Question: What's up?>

# Request an ID that doesn't exist, this will raise an exception.
>>> Question.objects.get(id=2)
Traceback (most recent call last):
    ...
DoesNotExist: Question matching query does not exist.

# Lookup by a primary key is the most common case, so Django provides a
# shortcut for primary-key exact lookups.
# The following is identical to Question.objects.get(id=1).
>>> Question.objects.get(pk=1)
<Question: What's up?>

# Make sure our custom method worked.
>>> q = Question.objects.get(pk=1)
>>> q.was_published_recently()
True

# Give the Question a couple of Choices. The create call constructs a new
# Choice object, does the INSERT statement, adds the choice to the set
# of available choices and returns the new Choice object. Django creates
# a set to hold the "other side" of a ForeignKey relation
# (e.g. a question's choice) which can be accessed via the API.
>>> q = Question.objects.get(pk=1)

# Display any choices from the related object set -- none so far.
>>> q.choice_set.all()
<QuerySet []>

# Create three choices.
>>> q.choice_set.create(choice_text='Not much', votes=0)
<Choice: Not much>
>>> q.choice_set.create(choice_text='The sky', votes=0)
<Choice: The sky>
>>> c = q.choice_set.create(choice_text='Just hacking again', votes=0)

# Choice objects have API access to their related Question objects.
>>> c.question
<Question: What's up?>

# And vice versa: Question objects get access to Choice objects.
>>> q.choice_set.all()
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>
>>> q.choice_set.count()
3

# The API automatically follows relationships as far as you need.
# Use double underscores to separate relationships.
# This works as many levels deep as you want; there's no limit.
# Find all Choices for any question whose pub_date is in this year
# (reusing the 'current_year' variable we created above).
>>> Choice.objects.filter(question__pub_date__year=current_year)
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>

# Let's delete one of the choices. Use delete() for that.
>>> c = q.choice_set.filter(choice_text__startswith='Just hacking')
>>> c.delete()
```

## Introducing the Django Admin

### Creating an admin user
`python manage.py createsuperuser`

Enter your desired username and password.(admin/admintest)

### Start the development server and login in
`python manage.py runserver`

Admin url(default): http://127.0.0.1:8000/admin/

### Make the poll app modifiable in the admin
Open the `polls/admin.py` and edit it:
```python
from django.contrib import admin
from .models import Question

admin.site.register(Question)
```